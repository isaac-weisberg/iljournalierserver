// Code generated by "go-jason-gen"; DO NOT EDIT.

package main

import (
	"errors"
	"fmt"

	gojason "github.com/isaac-weisberg/go-jason"
	parser "github.com/isaac-weisberg/go-jason/parser"
	values "github.com/isaac-weisberg/go-jason/values"
)

// just in case, if variable is unused, we mention it as a param to this no-op func - and then, it's suddenly very well used :)
func UNUSED(arg any) {}

func makeAccessTokenHavingRequestFromJson(bytes []byte) (*accessTokenHavingRequest, error) {
	var j = errors.Join
	var e = errors.New
	UNUSED(fmt.Sprintf)

	rootValueAny, err := parser.Parse(bytes)
	if err != nil {
		return nil, j(e("parsing json into an object tree failed"), err)
	}

	rootObject, err := rootValueAny.AsObject()
	if err != nil {
		return nil, j(e("interpreting root json value as an object failed"), err)
	}

	parsedObject, err := parseAccessTokenHavingRequestFromJsonObject(rootObject)
	if err != nil {
		return nil, j(e("parsing json into the resulting value failed"), err)
	}

	return parsedObject, nil
}

func parseAccessTokenHavingRequestFromJsonObject(rootObject *values.JsonValueObject) (*accessTokenHavingRequest, error) {
	var j = errors.Join
	var e = errors.New

	var stringKeyValues = rootObject.StringKeyedKeyValuesOnly()
	UNUSED(stringKeyValues)

	valueForAccessTokenKey, exists := stringKeyValues["accessToken"]
	if !exists {
		return nil, j(e("value not found for key 'accessToken'"))
	}
	valueForAccessTokenKeyAsStringValue, err := valueForAccessTokenKey.AsString()
	if err != nil {
		return nil, j(e("interpreting JsonAny as String failed for key 'accessToken'"), err)
	}
	parsedStringForAccessTokenKey := valueForAccessTokenKeyAsStringValue.String

	var decodable = gojason.Decodable{}
	var resultingStructAccessTokenHavingRequest = accessTokenHavingRequest{
		Decodable: decodable,
		accessToken: parsedStringForAccessTokenKey,
	}
	return &resultingStructAccessTokenHavingRequest, nil
}

func makeGetKnownFlagsRequestBodyFromJson(bytes []byte) (*getKnownFlagsRequestBody, error) {
	var j = errors.Join
	var e = errors.New
	UNUSED(fmt.Sprintf)

	rootValueAny, err := parser.Parse(bytes)
	if err != nil {
		return nil, j(e("parsing json into an object tree failed"), err)
	}

	rootObject, err := rootValueAny.AsObject()
	if err != nil {
		return nil, j(e("interpreting root json value as an object failed"), err)
	}

	parsedObject, err := parseGetKnownFlagsRequestBodyFromJsonObject(rootObject)
	if err != nil {
		return nil, j(e("parsing json into the resulting value failed"), err)
	}

	return parsedObject, nil
}

func parseGetKnownFlagsRequestBodyFromJsonObject(rootObject *values.JsonValueObject) (*getKnownFlagsRequestBody, error) {
	var j = errors.Join
	var e = errors.New

	var stringKeyValues = rootObject.StringKeyedKeyValuesOnly()
	UNUSED(stringKeyValues)

	valueForEmbeddedAccessTokenHavingRequest, err := parseAccessTokenHavingRequestFromJsonObject(rootObject)
	if err != nil {
		return nil, j(e("parsing embedded struct of type 'accessTokenHavingRequest' failed"), err)
	}

	var decodable = gojason.Decodable{}
	var resultingStructGetKnownFlagsRequestBody = getKnownFlagsRequestBody{
		Decodable: decodable,
		accessTokenHavingRequest: *valueForEmbeddedAccessTokenHavingRequest,
	}
	return &resultingStructGetKnownFlagsRequestBody, nil
}

